/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * â˜¿ï¸ MERCURY RELAY â€” LE RELAIS SUPRACONDUCTEUR
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 *   â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
 *   â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•
 *   â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• 
 *   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•  
 *   â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 *   â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   
 * 
 *                    RELAIS SUPRACONDUCTEUR
 * 
 * Le Mercure est le messager des Dieux dans la tradition alchimique.
 * Dans ATÂ·OM, il transporte l'information entre les agents instantanÃ©ment.
 * 
 * PropriÃ©tÃ©s:
 * - SupraconductivitÃ©: ZÃ©ro rÃ©sistance au flux d'information
 * - Vif-argent: S'adapte Ã  n'importe quel container
 * - Transmutation: Transforme les donnÃ©es en mouvement
 * 
 * @version 2.0.0
 * @architect Jonathan Rodrigue (999 Hz)
 * @frequency 741 Hz (Purificateur)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTES DU MERCURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const MERCURY_CONSTANTS = {
  name: "Mercure",
  aliases: ["Vif-argent", "Hydrargyrum", "Quicksilver"],
  symbol: "â˜¿",
  element: "Hg",
  atomicNumber: 80,
  frequency: 741,
  
  // PropriÃ©tÃ©s alchimiques
  alchemy: {
    stage: "Albedo (Blanchiment)",
    role: "Le Messager",
    patron: "HermÃ¨s/Mercure/Thoth",
    quality: "Volatil, Fluide, Adaptable",
    polarity: "Neutre (ni fixe ni volatil)"
  },
  
  // PropriÃ©tÃ©s techniques
  technical: {
    state: "Liquide Ã  tempÃ©rature ambiante",
    conductivity: "Supraconducteur dans ATÂ·OM",
    latency: "0 ms (thÃ©orique)",
    bandwidth: "IllimitÃ©",
    protocol: "HERMETIC_TRANSMISSION_PROTOCOL"
  },
  
  // Correspondances
  correspondences: {
    day: "Mercredi",
    planet: "Mercure",
    chakra: "Vishuddha (Gorge)",
    sephirah: "Hod (Splendeur)",
    color: "#C0C0C0",
    metal: "Mercure / Vif-argent"
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUFFER DE TRANSMISSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Buffer circulaire pour les messages en transit
 */
class TransmissionBuffer {
  constructor(size = 999) {
    this.buffer = new Array(size);
    this.head = 0;
    this.tail = 0;
    this.size = size;
    this.count = 0;
  }
  
  push(message) {
    this.buffer[this.tail] = {
      ...message,
      timestamp: Date.now(),
      id: `HG_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };
    this.tail = (this.tail + 1) % this.size;
    
    if (this.count < this.size) {
      this.count++;
    } else {
      this.head = (this.head + 1) % this.size;
    }
    
    return this.buffer[(this.tail - 1 + this.size) % this.size];
  }
  
  pop() {
    if (this.count === 0) return null;
    
    const message = this.buffer[this.head];
    this.head = (this.head + 1) % this.size;
    this.count--;
    
    return message;
  }
  
  peek() {
    return this.count > 0 ? this.buffer[this.head] : null;
  }
  
  getAll() {
    const messages = [];
    let index = this.head;
    
    for (let i = 0; i < this.count; i++) {
      messages.push(this.buffer[index]);
      index = (index + 1) % this.size;
    }
    
    return messages;
  }
  
  clear() {
    this.head = 0;
    this.tail = 0;
    this.count = 0;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LE RELAIS DE MERCURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const MercuryRelay = {
  // Ã‰tat
  state: "DORMANT",
  temperature: 0, // 0 = froid, 100 = surchauffe
  transmissionCount: 0,
  buffer: new TransmissionBuffer(999),
  subscribers: new Map(),
  
  // Statistiques
  stats: {
    totalTransmissions: 0,
    successfulTransmissions: 0,
    failedTransmissions: 0,
    averageLatency: 0,
    peakLoad: 0
  },
  
  /**
   * Initialise le relais de Mercure
   * @returns {Object} Ã‰tat d'initialisation
   */
  initialize() {
    this.state = "WARMING";
    this.temperature = 0;
    
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â˜¿ï¸ MERCURY RELAY â€” INITIALISATION                            â•‘
â•‘                                                               â•‘
â•‘  Ã‰tat:       ${this.state.padEnd(40)}â•‘
â•‘  FrÃ©quence:  741 Hz (Purificateur)                           â•‘
â•‘  Protocole:  HERMETIC_TRANSMISSION_PROTOCOL                  â•‘
â•‘  Buffer:     999 messages max                                 â•‘
â•‘                                                               â•‘
â•‘  ğŸŒ¡ï¸ Mercure en train de chauffer...                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);
    
    // Simulation de chauffage
    this.warmUp();
    
    return {
      state: this.state,
      ready: false,
      message: "Mercure en cours d'initialisation"
    };
  },
  
  /**
   * Chauffe le Mercure jusqu'Ã  l'Ã©tat fluide
   */
  warmUp() {
    const warmingInterval = setInterval(() => {
      this.temperature += 10;
      
      if (this.temperature >= 100) {
        clearInterval(warmingInterval);
        this.state = "FLUID";
        console.log("â˜¿ï¸ Mercure FLUIDE â€” SupraconductivitÃ© active");
        this.emit("RELAY_READY", { state: this.state });
      }
    }, 100);
  },
  
  /**
   * Transmet un message via le relais
   * @param {string} type - Type de message
   * @param {any} data - DonnÃ©es Ã  transmettre
   * @param {Object} options - Options de transmission
   * @returns {Object} RÃ©sultat de la transmission
   */
  transmit(type, data, options = {}) {
    if (this.state === "DORMANT") {
      console.warn("â˜¿ï¸ Mercure dormant â€” Initialisation automatique");
      this.initialize();
    }
    
    const startTime = performance.now();
    
    // CrÃ©er le message
    const message = {
      type: type,
      data: data,
      source: options.source || "UNKNOWN",
      destination: options.destination || "BROADCAST",
      priority: options.priority || "NORMAL",
      frequency: options.frequency || 741,
      encrypted: options.encrypted || false
    };
    
    // Ajouter au buffer
    const bufferedMessage = this.buffer.push(message);
    
    // Mettre Ã  jour les stats
    this.transmissionCount++;
    this.stats.totalTransmissions++;
    
    const endTime = performance.now();
    const latency = endTime - startTime;
    
    // Calculer la latence moyenne
    this.stats.averageLatency = (
      (this.stats.averageLatency * (this.stats.totalTransmissions - 1) + latency) /
      this.stats.totalTransmissions
    );
    
    // Log de transmission
    console.log(`â˜¿ï¸ TRANSMISSION [${type}]`);
    console.log(`   â†’ De: ${message.source}`);
    console.log(`   â†’ Vers: ${message.destination}`);
    console.log(`   â†’ FrÃ©quence: ${message.frequency} Hz`);
    console.log(`   â†’ Latence: ${latency.toFixed(3)} ms`);
    
    // Notifier les abonnÃ©s
    this.notifySubscribers(type, bufferedMessage);
    
    this.stats.successfulTransmissions++;
    
    return {
      success: true,
      messageId: bufferedMessage.id,
      type: type,
      latency: latency,
      timestamp: bufferedMessage.timestamp
    };
  },
  
  /**
   * Ã‰met un signal Ã  tous les abonnÃ©s
   * @param {string} event - Nom de l'Ã©vÃ©nement
   * @param {any} data - DonnÃ©es de l'Ã©vÃ©nement
   */
  emit(event, data) {
    this.notifySubscribers(event, data);
  },
  
  /**
   * S'abonne Ã  un type de message
   * @param {string} type - Type de message
   * @param {Function} callback - Fonction de rappel
   * @returns {string} ID d'abonnement
   */
  subscribe(type, callback) {
    const subscriberId = `SUB_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    if (!this.subscribers.has(type)) {
      this.subscribers.set(type, new Map());
    }
    
    this.subscribers.get(type).set(subscriberId, callback);
    
    console.log(`â˜¿ï¸ Nouvel abonnÃ© pour "${type}": ${subscriberId}`);
    
    return subscriberId;
  },
  
  /**
   * Se dÃ©sabonne d'un type de message
   * @param {string} type - Type de message
   * @param {string} subscriberId - ID d'abonnement
   */
  unsubscribe(type, subscriberId) {
    if (this.subscribers.has(type)) {
      this.subscribers.get(type).delete(subscriberId);
      console.log(`â˜¿ï¸ AbonnÃ© retirÃ© de "${type}": ${subscriberId}`);
    }
  },
  
  /**
   * Notifie tous les abonnÃ©s d'un type
   * @param {string} type - Type de message
   * @param {any} data - DonnÃ©es du message
   */
  notifySubscribers(type, data) {
    // AbonnÃ©s spÃ©cifiques au type
    if (this.subscribers.has(type)) {
      for (const callback of this.subscribers.get(type).values()) {
        try {
          callback(data);
        } catch (error) {
          console.error(`â˜¿ï¸ Erreur dans callback pour "${type}":`, error);
        }
      }
    }
    
    // AbonnÃ©s globaux (*)
    if (this.subscribers.has("*")) {
      for (const callback of this.subscribers.get("*").values()) {
        try {
          callback({ type, data });
        } catch (error) {
          console.error(`â˜¿ï¸ Erreur dans callback global:`, error);
        }
      }
    }
  },
  
  /**
   * RÃ©cupÃ¨re les messages en attente
   * @param {string} type - Type de message (optionnel)
   * @returns {Array} Messages
   */
  receive(type = null) {
    const messages = this.buffer.getAll();
    
    if (type) {
      return messages.filter(m => m.type === type);
    }
    
    return messages;
  },
  
  /**
   * Vide le buffer de transmission
   */
  flush() {
    this.buffer.clear();
    console.log("â˜¿ï¸ Buffer de transmission vidÃ©");
  },
  
  /**
   * Retourne les statistiques du relais
   * @returns {Object} Statistiques
   */
  getStats() {
    return {
      ...this.stats,
      state: this.state,
      temperature: this.temperature,
      bufferCount: this.buffer.count,
      subscriberCount: Array.from(this.subscribers.values())
        .reduce((sum, map) => sum + map.size, 0)
    };
  },
  
  /**
   * Met le relais en veille
   */
  sleep() {
    this.state = "DORMANT";
    this.temperature = 0;
    console.log("â˜¿ï¸ Mercure en veille");
  },
  
  /**
   * VÃ©rifie si le relais est prÃªt
   * @returns {boolean}
   */
  isReady() {
    return this.state === "FLUID";
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VORTEX DE TRANSMISSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Le Vortex accÃ©lÃ¨re les transmissions en crÃ©ant un tunnel de Mercure
 */
export const MercuryVortex = {
  active: false,
  speed: 1,
  
  /**
   * Active le vortex de Mercure
   * @param {number} speed - Multiplicateur de vitesse
   */
  activate(speed = 10) {
    this.active = true;
    this.speed = speed;
    
    console.log(`
    ğŸŒ€ VORTEX DE MERCURE ACTIVÃ‰
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Vitesse:     ${speed}x
    Latence:     ~0 ms
    CapacitÃ©:    IllimitÃ©e
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);
    
    return { active: true, speed: this.speed };
  },
  
  /**
   * DÃ©sactive le vortex
   */
  deactivate() {
    this.active = false;
    this.speed = 1;
    console.log("ğŸŒ€ Vortex de Mercure dÃ©sactivÃ©");
  },
  
  /**
   * Transmission accÃ©lÃ©rÃ©e via le vortex
   * @param {string} type - Type de message
   * @param {any} data - DonnÃ©es
   * @returns {Object} RÃ©sultat
   */
  transmit(type, data) {
    if (!this.active) {
      console.warn("ğŸŒ€ Vortex inactif â€” Activation automatique");
      this.activate();
    }
    
    return MercuryRelay.transmit(type, data, {
      priority: "VORTEX",
      frequency: 999 * this.speed
    });
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT PAR DÃ‰FAUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default MercuryRelay;
