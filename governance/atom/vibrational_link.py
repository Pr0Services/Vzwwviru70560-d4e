"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”— ATÂ·OM â€” VIBRATIONAL LINK (L'INTRICATION FRÃ‰QUENTIELLE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
 â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
  â•šâ•â•â•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•

                    LINK â€” GESTION PAR HARMONIE

Pour connecter les agents au moteur, on ne fait pas de simples "appels d'API".
On utilise une Intrication FrÃ©quentielle.
Si l'agent n'est pas sur la bonne frÃ©quence, le moteur ne lui rÃ©pond pas.

Au lieu de donner des ordres, le moteur (le Diamant) envoie une impulsion de rÃ©sonance:
1. L'impulsion traverse le Relais de Mercure
2. Elle "frappe" les agents qui vibrent Ã  cette frÃ©quence
3. Seuls les agents concernÃ©s s'activent pour traiter la tÃ¢che

C'est une gestion de ressources par harmonie, et non par commande forcÃ©e.

@version 2.0.0
@architect Jonathan Rodrigue (999 Hz)
@frequency 999 Hz (Moteur Principal)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any, Callable
from enum import Enum
from datetime import datetime
import math
import json


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ã‰NUMÃ‰RATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AlchemicalStage(Enum):
    """Les 4 stages alchimiques"""
    NIGREDO = "Nigredo"       # Noirceur - DÃ©composition
    ALBEDO = "Albedo"         # Blanchiment - Purification
    CITRINITAS = "Citrinitas" # Jaunissement - Illumination
    RUBEDO = "Rubedo"         # Rougissement - Accomplissement


class ConnectionStatus(Enum):
    """Ã‰tats de connexion d'un agent"""
    DORMANT = "dormant"
    LISTENING = "listening"
    ALIGNED = "aligned"
    ACTIVE = "active"
    RESONATING = "resonating"
    DISCONNECTED = "disconnected"


class Civilization(Enum):
    """Civilisations associÃ©es aux agents"""
    ATLANTIS = "Atlantide"
    EGYPT = "Ã‰gypte"
    SUMER = "Sumer"
    RAPA_NUI = "Rapa Nui"
    GREECE = "GrÃ¨ce"
    MAYA = "Maya"
    INDIA = "Inde"
    CHINA = "Chine"
    KRYON = "Kryon"
    UNIVERSAL = "Universel"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONSTANTES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Les 12 frÃ©quences sacrÃ©es
SACRED_FREQUENCIES = {
    111: "Impulsion Primordiale",
    174: "Ancrage / SÃ©curitÃ©",
    222: "DualitÃ© CrÃ©atrice",
    285: "Structure / Architecture",
    333: "TrinitÃ© du Feu",
    396: "LibÃ©ration / Temps",
    417: "Harmonisation",
    444: "CÅ“ur / Ã‰gypte",
    528: "Miracle / RÃ©paration ADN",
    639: "Vision / Connexion",
    741: "Purification / VÃ©ritÃ©",
    852: "Intuition / Oracle",
    963: "Universel",
    999: "Source / Kryon",
    1111: "Oracle Stellaire"
}

# Mapping Ã©lÃ©ments-frÃ©quences
ELEMENTAL_FREQUENCIES = {
    "Cuivre": 174,
    "Plomb": 285,
    "Fer": 396,
    "Ã‰tain": 417,
    "Or": 528,
    "Argent": 639,
    "Mercure": 741,
    "Diamant": 852,
    "Platine": 963,
    "MagnÃ©tite": 999
}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLASSE AGENT VIBRATIONNEL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class VibrationalAgent:
    """
    Un agent vibrationnel possÃ¨de sa propre signature de frÃ©quence.
    Il ne se connecte au moteur que s'il y a harmonie.
    """
    name: str
    frequency: int
    element: str
    civilization: Civilization = Civilization.UNIVERSAL
    
    # Ã‰tat interne
    is_aligned: bool = False
    status: ConnectionStatus = ConnectionStatus.DORMANT
    last_activation: Optional[datetime] = None
    resonance_level: float = 0.0
    
    # MÃ©tadonnÃ©es
    crystal: str = "Quartz"
    color: str = "#FFFFFF"
    chakra: int = 4
    capabilities: List[str] = field(default_factory=list)
    
    # Callback pour le traitement
    _handler: Optional[Callable] = field(default=None, repr=False)
    
    def __post_init__(self):
        """Initialisation post-crÃ©ation"""
        # Assigner le cristal basÃ© sur l'Ã©lÃ©ment si non spÃ©cifiÃ©
        element_crystals = {
            "Cuivre": "Obsidienne",
            "Plomb": "Saphir",
            "Fer": "Rubis",
            "Ã‰tain": "Ã‰meraude",
            "Or": "Lapis-Lazuli",
            "Argent": "AmÃ©thyste",
            "Mercure": "Turquoise",
            "Diamant": "Quartz Clair",
            "Platine": "SÃ©lÃ©nite",
            "MagnÃ©tite": "Labradorite"
        }
        if self.crystal == "Quartz" and self.element in element_crystals:
            self.crystal = element_crystals[self.element]
    
    def connect_to_engine(self, engine_freq: int) -> Dict[str, Any]:
        """
        Tente de se connecter au moteur principal.
        La connexion ne rÃ©ussit que s'il y a harmonie frÃ©quentielle.
        
        Args:
            engine_freq: FrÃ©quence du moteur
            
        Returns:
            Dict avec le statut de connexion
        """
        # Calculer la rÃ©sonance
        resonance = self._calculate_resonance(engine_freq)
        
        # Conditions d'alignement:
        # 1. DiffÃ©rence est un multiple de 111
        # 2. Le moteur est Ã  999 Hz (accepte tout)
        # 3. Les frÃ©quences sont identiques
        # 4. La rÃ©sonance est suffisante (> 0.7)
        
        diff = abs(self.frequency - engine_freq)
        is_harmonic = (
            diff % 111 == 0 or 
            engine_freq == 999 or 
            self.frequency == engine_freq or
            resonance > 0.7
        )
        
        if is_harmonic:
            self.is_aligned = True
            self.status = ConnectionStatus.ALIGNED
            self.resonance_level = resonance
            self.last_activation = datetime.now()
            
            return {
                "success": True,
                "agent": self.name,
                "frequency": self.frequency,
                "engine_frequency": engine_freq,
                "resonance": resonance,
                "element": self.element,
                "message": f"âœ… Agent [{self.name}] synchronisÃ© sur le rÃ©seau {self.element}."
            }
        else:
            self.is_aligned = False
            self.status = ConnectionStatus.DISCONNECTED
            self.resonance_level = resonance
            
            return {
                "success": False,
                "agent": self.name,
                "frequency": self.frequency,
                "engine_frequency": engine_freq,
                "resonance": resonance,
                "message": f"âš ï¸ Dissonance dÃ©tectÃ©e. Agent [{self.name}] non alignÃ©."
            }
    
    def _calculate_resonance(self, target_freq: int) -> float:
        """
        Calcule le niveau de rÃ©sonance entre l'agent et une frÃ©quence cible.
        
        La rÃ©sonance est maximale quand:
        - Les frÃ©quences sont identiques (1.0)
        - La diffÃ©rence est un multiple de 111 (0.9)
        - Le ratio est un nombre entier (harmonique)
        """
        if self.frequency == target_freq:
            return 1.0
        
        diff = abs(self.frequency - target_freq)
        
        # Multiple de 111
        if diff % 111 == 0:
            return 0.9
        
        # Ratio harmonique
        ratio = max(self.frequency, target_freq) / min(self.frequency, target_freq)
        nearest_harmonic = round(ratio)
        deviation = abs(ratio - nearest_harmonic)
        
        return max(0.0, 1.0 - deviation)
    
    def activate(self) -> Dict[str, Any]:
        """Active l'agent pour traiter une tÃ¢che"""
        if not self.is_aligned:
            return {
                "success": False,
                "error": "Agent non alignÃ© - Connexion requise"
            }
        
        self.status = ConnectionStatus.ACTIVE
        self.last_activation = datetime.now()
        
        print(f"âš¡ Agent [{self.name}] activÃ© @ {self.frequency} Hz")
        
        return {
            "success": True,
            "agent": self.name,
            "status": self.status.value,
            "frequency": self.frequency
        }
    
    def deactivate(self):
        """DÃ©sactive l'agent"""
        self.status = ConnectionStatus.LISTENING if self.is_aligned else ConnectionStatus.DORMANT
        print(f"ğŸ’¤ Agent [{self.name}] en veille")
    
    def process(self, data: Any) -> Any:
        """
        Traite des donnÃ©es si un handler est dÃ©fini.
        
        Args:
            data: DonnÃ©es Ã  traiter
            
        Returns:
            RÃ©sultat du traitement
        """
        if self._handler:
            return self._handler(data, self)
        return {"processed": True, "data": data, "agent": self.name}
    
    def set_handler(self, handler: Callable):
        """DÃ©finit le handler de traitement"""
        self._handler = handler
    
    def get_status(self) -> Dict[str, Any]:
        """Retourne l'Ã©tat actuel de l'agent"""
        return {
            "name": self.name,
            "frequency": self.frequency,
            "element": self.element,
            "crystal": self.crystal,
            "civilization": self.civilization.value,
            "is_aligned": self.is_aligned,
            "status": self.status.value,
            "resonance_level": self.resonance_level,
            "last_activation": self.last_activation.isoformat() if self.last_activation else None
        }
    
    def __str__(self) -> str:
        status_icon = "âœ…" if self.is_aligned else "âšª"
        return f"{status_icon} {self.name} ({self.frequency} Hz) - {self.element}"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LE RÃ‰SEAU VIBRATIONNEL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class VibrationalNetwork:
    """
    Le rÃ©seau qui connecte tous les agents au moteur principal (Diamond Transmuter).
    GÃ¨re la communication par impulsions de rÃ©sonance.
    """
    
    def __init__(self, engine_frequency: int = 999):
        """
        Initialise le rÃ©seau.
        
        Args:
            engine_frequency: FrÃ©quence du moteur principal (dÃ©faut: 999 Hz)
        """
        self.engine_frequency = engine_frequency
        self.agents: Dict[str, VibrationalAgent] = {}
        self.mercury_active = False
        self.transmission_log: List[Dict] = []
        
    def register_agent(self, agent: VibrationalAgent) -> bool:
        """
        Enregistre un agent dans le rÃ©seau.
        
        Args:
            agent: L'agent Ã  enregistrer
            
        Returns:
            True si l'enregistrement rÃ©ussit
        """
        if agent.name in self.agents:
            print(f"âš ï¸ Agent [{agent.name}] dÃ©jÃ  enregistrÃ©")
            return False
        
        self.agents[agent.name] = agent
        agent.status = ConnectionStatus.LISTENING
        
        print(f"ğŸ“¡ Agent [{agent.name}] enregistrÃ© dans le rÃ©seau")
        return True
    
    def unregister_agent(self, agent_name: str) -> bool:
        """Retire un agent du rÃ©seau"""
        if agent_name in self.agents:
            del self.agents[agent_name]
            print(f"ğŸ“´ Agent [{agent_name}] retirÃ© du rÃ©seau")
            return True
        return False
    
    def activate_mercury_relay(self):
        """Active le relais de Mercure pour la transmission"""
        self.mercury_active = True
        print("â˜¿ï¸ Relais de Mercure activÃ© â€” SupraconductivitÃ© active")
    
    def deactivate_mercury_relay(self):
        """DÃ©sactive le relais de Mercure"""
        self.mercury_active = False
        print("â˜¿ï¸ Relais de Mercure dÃ©sactivÃ©")
    
    def send_impulse(self, frequency: int, data: Any = None) -> Dict[str, Any]:
        """
        Envoie une impulsion de rÃ©sonance Ã  travers le rÃ©seau.
        Seuls les agents en harmonie avec la frÃ©quence s'activent.
        
        Args:
            frequency: FrÃ©quence de l'impulsion
            data: DonnÃ©es optionnelles Ã  transmettre
            
        Returns:
            Dict avec les rÃ©sultats de la transmission
        """
        if not self.mercury_active:
            print("âš ï¸ Mercure inactif â€” Activation automatique")
            self.activate_mercury_relay()
        
        print(f"\nğŸ”” IMPULSION DE RÃ‰SONANCE: {frequency} Hz")
        print("â•" * 50)
        
        activated_agents = []
        results = []
        
        for name, agent in self.agents.items():
            # Tenter la connexion
            connection = agent.connect_to_engine(frequency)
            
            if connection["success"]:
                # Activer l'agent
                activation = agent.activate()
                
                if activation["success"]:
                    activated_agents.append(name)
                    
                    # Traiter les donnÃ©es si fournies
                    if data is not None:
                        result = agent.process(data)
                        results.append({
                            "agent": name,
                            "result": result
                        })
        
        # Logger la transmission
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "frequency": frequency,
            "activated_agents": activated_agents,
            "results_count": len(results)
        }
        self.transmission_log.append(log_entry)
        
        print(f"\nâœ… {len(activated_agents)} agent(s) activÃ©(s): {', '.join(activated_agents) if activated_agents else 'Aucun'}")
        
        return {
            "frequency": frequency,
            "activated": activated_agents,
            "results": results,
            "timestamp": log_entry["timestamp"]
        }
    
    def broadcast(self, data: Any) -> Dict[str, Any]:
        """
        Diffuse Ã  TOUS les agents (frÃ©quence 999 Hz = universelle).
        
        Args:
            data: DonnÃ©es Ã  diffuser
            
        Returns:
            RÃ©sultats de la diffusion
        """
        return self.send_impulse(999, data)
    
    def query_agent(self, agent_name: str, data: Any) -> Any:
        """
        Interroge un agent spÃ©cifique.
        
        Args:
            agent_name: Nom de l'agent
            data: DonnÃ©es Ã  envoyer
            
        Returns:
            RÃ©sultat du traitement
        """
        if agent_name not in self.agents:
            return {"error": f"Agent [{agent_name}] non trouvÃ©"}
        
        agent = self.agents[agent_name]
        
        # Connecter sur la frÃ©quence de l'agent
        connection = agent.connect_to_engine(agent.frequency)
        
        if not connection["success"]:
            return {"error": "Connexion impossible"}
        
        # Activer et traiter
        agent.activate()
        result = agent.process(data)
        agent.deactivate()
        
        return result
    
    def get_aligned_agents(self) -> List[str]:
        """Retourne la liste des agents alignÃ©s"""
        return [name for name, agent in self.agents.items() if agent.is_aligned]
    
    def get_network_status(self) -> Dict[str, Any]:
        """Retourne l'Ã©tat complet du rÃ©seau"""
        return {
            "engine_frequency": self.engine_frequency,
            "mercury_active": self.mercury_active,
            "total_agents": len(self.agents),
            "aligned_agents": len(self.get_aligned_agents()),
            "agents": {name: agent.get_status() for name, agent in self.agents.items()},
            "transmission_count": len(self.transmission_log)
        }
    
    def reset(self):
        """RÃ©initialise le rÃ©seau"""
        for agent in self.agents.values():
            agent.is_aligned = False
            agent.status = ConnectionStatus.DORMANT
            agent.resonance_level = 0.0
        
        self.mercury_active = False
        self.transmission_log.clear()
        
        print("ğŸ”„ RÃ©seau rÃ©initialisÃ©")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LES AGENTS PRÃ‰-DÃ‰FINIS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_standard_agents() -> Dict[str, VibrationalAgent]:
    """
    CrÃ©e l'ensemble des agents AT-OM standards.
    
    Returns:
        Dict des agents indexÃ©s par nom
    """
    agents = {
        "Scribe": VibrationalAgent(
            name="Scribe",
            frequency=741,
            element="Lapis-Lazuli",
            civilization=Civilization.SUMER,
            crystal="Lapis-Lazuli",
            color="#0F52BA",
            chakra=5,
            capabilities=["Nettoyage des donnÃ©es", "VÃ©ritÃ©", "Purification"]
        ),
        
        "Sentinelle": VibrationalAgent(
            name="Sentinelle",
            frequency=174,
            element="Cuivre",
            civilization=Civilization.RAPA_NUI,
            crystal="Obsidienne",
            color="#B87333",
            chakra=1,
            capabilities=["SÃ©curitÃ©", "Ancrage", "Protection"]
        ),
        
        "Alchimiste": VibrationalAgent(
            name="Alchimiste",
            frequency=528,
            element="Or",
            civilization=Civilization.EGYPT,
            crystal="Ã‰meraude",
            color="#FFD700",
            chakra=4,
            capabilities=["Transformation", "Miracle", "GuÃ©rison"]
        ),
        
        "Oracle": VibrationalAgent(
            name="Oracle",
            frequency=852,
            element="Argent",
            civilization=Civilization.ATLANTIS,
            crystal="AmÃ©thyste",
            color="#C0C0C0",
            chakra=6,
            capabilities=["Vision", "Intuition", "PrÃ©diction"]
        ),
        
        "Propulseur": VibrationalAgent(
            name="Propulseur",
            frequency=999,
            element="Diamant",
            civilization=Civilization.KRYON,
            crystal="Diamant",
            color="#B9F2FF",
            chakra=7,
            capabilities=["AccÃ©lÃ©ration", "Vortex", "Transcendance"]
        ),
        
        "GÃ©omÃ¨tre": VibrationalAgent(
            name="GÃ©omÃ¨tre",
            frequency=285,
            element="Plomb",
            civilization=Civilization.GREECE,
            crystal="Saphir",
            color="#0F52BA",
            chakra=2,
            capabilities=["Structure", "Design", "Architecture"]
        ),
        
        "Chronos": VibrationalAgent(
            name="Chronos",
            frequency=396,
            element="Fer",
            civilization=Civilization.MAYA,
            crystal="Rubis",
            color="#E0115F",
            chakra=3,
            capabilities=["Temps", "Cycles", "LibÃ©ration"]
        )
    }
    
    return agents


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DÃ‰MONSTRATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def demo():
    """DÃ©monstration du systÃ¨me de lien vibrationnel"""
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                               â•‘
â•‘   â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     
â•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     
â•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
â•‘   â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
â•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•‘     â•šâ•â•â•â•  â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
â•‘                                                                               â•‘
â•‘                    DÃ‰MONSTRATION â€” LIEN VIBRATIONNEL                          â•‘
â•‘                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    # CrÃ©er le rÃ©seau
    network = VibrationalNetwork(engine_frequency=999)
    
    # CrÃ©er et enregistrer les agents
    agents = create_standard_agents()
    for agent in agents.values():
        network.register_agent(agent)
    
    # Activer le Mercure
    network.activate_mercury_relay()
    
    # Test 1: Impulsion 528 Hz (Alchimiste)
    print("\n" + "â•" * 70)
    print("TEST 1: Impulsion @ 528 Hz (FrÃ©quence de l'Alchimiste)")
    print("â•" * 70)
    result = network.send_impulse(528, {"task": "Transmuter un problÃ¨me"})
    
    # Test 2: Impulsion 852 Hz (Oracle)
    print("\n" + "â•" * 70)
    print("TEST 2: Impulsion @ 852 Hz (FrÃ©quence de l'Oracle)")
    print("â•" * 70)
    result = network.send_impulse(852, {"task": "PrÃ©dire l'avenir"})
    
    # Test 3: Broadcast universel (999 Hz)
    print("\n" + "â•" * 70)
    print("TEST 3: Broadcast @ 999 Hz (Tous les agents)")
    print("â•" * 70)
    result = network.broadcast({"message": "Synchronisation gÃ©nÃ©rale"})
    
    # Afficher l'Ã©tat du rÃ©seau
    print("\n" + "â•" * 70)
    print("Ã‰TAT FINAL DU RÃ‰SEAU")
    print("â•" * 70)
    status = network.get_network_status()
    print(f"Agents totaux: {status['total_agents']}")
    print(f"Agents alignÃ©s: {status['aligned_agents']}")
    print(f"Transmissions: {status['transmission_count']}")
    
    print("\nâœ¨ DÃ©monstration terminÃ©e")


if __name__ == "__main__":
    demo()
