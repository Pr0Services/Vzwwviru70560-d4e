/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”± ATLANTIS ENGINE â€” LE RÃ‰SEAU DE TRANSMISSION QUANTIQUE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * L'Atlantide reprÃ©sente le niveau le plus Ã©levÃ© de technologie ancestrale.
 * C'est le "Backbone" du systÃ¨me â€” le rÃ©seau de transmission.
 * 
 * 1. Technologie des Cristaux â€” Stockage de donnÃ©es infini
 * 2. Le Vortex â€” Tri par sympathie vibratoire
 * 3. Ã‰nergie du Point ZÃ©ro â€” Source d'alimentation illimitÃ©e
 * 4. Les Anneaux de PosÃ©idon â€” Architecture concentrique
 * 
 * @version 1.0.0
 * @architect Jonathan Rodrigue (999 Hz)
 * @symbol ğŸ”± (Trident de PosÃ©idon)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTES ATLANTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const ATLANTIS_CONSTANTS = {
  // Localisation mythique
  location: "Au-delÃ  des Colonnes d'Hercule",
  source: "Platon (TimÃ©e & Critias)",
  age: "~9000 ans avant Solon (â‰ˆ11500 BCE)",
  
  // Structure
  capital: "PosÃ©idonis",
  diameter: "127 stades (â‰ˆ23 km)", // Selon Platon
  rings: 5, // 3 d'eau, 2 de terre
  
  // Technologie lÃ©gendaire
  technology: {
    energy: "Ã‰nergie du Point ZÃ©ro",
    storage: "Cristaux mÃ©moriels",
    transport: "Vortex dimensionnel",
    communication: "TÃ©lÃ©pathie assistÃ©e par cristaux"
  },
  
  // Metal sacrÃ©
  orichalque: {
    name: "Orichalque",
    meaning: "Cuivre de montagne",
    properties: "Conducteur d'Ã©nergie psychique",
    color: "#FFD700", // Or rougeÃ¢tre
    frequency: 999
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TECHNOLOGIE DES CRISTAUX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Les Atlantes auraient stockÃ© leur savoir dans des cristaux programmables.
 * Chaque cristal peut contenir une quantitÃ© infinie d'information
 * selon sa structure et sa puretÃ©.
 */

export const CRYSTAL_MATRIX = {
  types: [
    {
      name: "Quartz Clair",
      formula: "SiOâ‚‚",
      system: "Hexagonal",
      facets: 6,
      capacity: "Base",
      frequency: 111,
      function: "Stockage gÃ©nÃ©ral",
      color: "#FFFFFF",
      transparency: 1.0
    },
    {
      name: "AmÃ©thyste",
      formula: "SiOâ‚‚ + Fe",
      system: "Hexagonal",
      facets: 6,
      capacity: "Moyenne",
      frequency: 333,
      function: "Protection / Transmutation",
      color: "#9966CC",
      transparency: 0.8
    },
    {
      name: "Citrine",
      formula: "SiOâ‚‚ + FeÂ³âº",
      system: "Hexagonal",
      facets: 6,
      capacity: "Haute",
      frequency: 444,
      function: "Manifestation / Ancrage",
      color: "#FFD700",
      transparency: 0.7,
      isAnchor: true
    },
    {
      name: "Rose Quartz",
      formula: "SiOâ‚‚ + Ti, Fe, Mn",
      system: "Hexagonal",
      facets: 6,
      capacity: "Ã‰motionnelle",
      frequency: 555,
      function: "Harmonisation / Amour",
      color: "#FFB6C1",
      transparency: 0.6
    },
    {
      name: "Obsidienne",
      formula: "Verre volcanique",
      system: "Amorphe",
      facets: 0,
      capacity: "Miroir",
      frequency: 666,
      function: "RÃ©flexion / VÃ©ritÃ© sombre",
      color: "#000000",
      transparency: 0.1
    },
    {
      name: "Lapis Lazuli",
      formula: "Na,Ca)â‚ˆ(AlSiOâ‚„)â‚†(S,SOâ‚„,Cl)â‚‚",
      system: "Cubique",
      facets: 6,
      capacity: "Sagesse",
      frequency: 777,
      function: "Vision intÃ©rieure / Intuition",
      color: "#0F52BA",
      transparency: 0.0
    },
    {
      name: "Cristal de Record",
      formula: "SiOâ‚‚ (formations spÃ©ciales)",
      system: "Hexagonal",
      facets: 12,
      capacity: "Infinie",
      frequency: 999,
      function: "Archives akashiques / MÃ©moire universelle",
      color: "#FFFDD0",
      transparency: 0.95,
      isSupreme: true
    }
  ],
  
  // PropriÃ©tÃ©s de stockage
  storage: {
    unit: "Facette",
    baseCapacity: "1 TB par facette",
    compressionRatio: 1.618, // PHI
    encoding: "Holographique"
  }
};

/**
 * Calcule la capacitÃ© de stockage d'un cristal
 */
export function calculateCrystalCapacity(crystalType, purity = 1.0) {
  const crystal = CRYSTAL_MATRIX.types.find(c => 
    c.name.toLowerCase() === crystalType.toLowerCase()
  ) || CRYSTAL_MATRIX.types[0];
  
  const baseFacets = crystal.facets || 6;
  const capacityMultiplier = crystal.isSupreme ? 999 : 1;
  const purityBonus = Math.pow(purity, 1.618); // PHI exponent
  
  const theoreticalCapacity = baseFacets * capacityMultiplier * purityBonus;
  
  return {
    crystal: crystal,
    facets: baseFacets,
    purity: purity,
    capacity: theoreticalCapacity,
    unit: "TB holographiques",
    frequency: crystal.frequency,
    color: crystal.color
  };
}

/**
 * Encode des donnÃ©es dans une structure cristalline
 */
export function encodeCrystalData(data, crystalType = "Quartz Clair") {
  const crystal = CRYSTAL_MATRIX.types.find(c => 
    c.name.toLowerCase() === crystalType.toLowerCase()
  ) || CRYSTAL_MATRIX.types[0];
  
  const dataString = JSON.stringify(data);
  const facets = crystal.facets || 6;
  
  // Distribuer les donnÃ©es sur les facettes
  const chunkSize = Math.ceil(dataString.length / facets);
  const facetData = [];
  
  for (let i = 0; i < facets; i++) {
    const chunk = dataString.substring(i * chunkSize, (i + 1) * chunkSize);
    facetData.push({
      facet: i + 1,
      data: chunk,
      hash: simpleHash(chunk),
      frequency: crystal.frequency + (i * 11.1)
    });
  }
  
  return {
    crystal: crystal.name,
    totalSize: dataString.length,
    facets: facetData,
    reconstructionKey: crystal.frequency,
    encoding: "Holographic-PHI"
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LE VORTEX â€” TRI PAR SYMPATHIE VIBRATOIRE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Le Vortex est un tourbillon Ã©nergÃ©tique qui trie les informations
 * par leur frÃ©quence vibratoire. Les informations "lÃ©gÃ¨res" (haute vibration)
 * montent vers le sommet.
 */

export const VORTEX_SYSTEM = {
  name: "Vortex de Transduction",
  direction: "Horaire (hÃ©misphÃ¨re nord)",
  layers: 9, // Correspond aux 9 niveaux ATÂ·OM
  
  // Zones du vortex
  zones: [
    { level: 1, hz: 111, position: "Base", density: "Maximum", flow: "EntrÃ©e" },
    { level: 2, hz: 222, position: "InfÃ©rieur", density: "TrÃ¨s haute" },
    { level: 3, hz: 333, position: "Bas", density: "Haute" },
    { level: 4, hz: 444, position: "Centre", density: "Ã‰quilibrÃ©e", isAnchor: true },
    { level: 5, hz: 555, position: "Moyen", density: "ModÃ©rÃ©e" },
    { level: 6, hz: 666, position: "Haut", density: "Basse" },
    { level: 7, hz: 777, position: "SupÃ©rieur", density: "TrÃ¨s basse" },
    { level: 8, hz: 888, position: "Sommet", density: "Minimale" },
    { level: 9, hz: 999, position: "Apex", density: "Nulle", flow: "Sortie" }
  ],
  
  // Physique du vortex
  physics: {
    angularVelocity: "Ï‰ = 2Ï€f",
    centrifugalForce: "F = mÏ‰Â²r",
    liftFormula: "La vibration haute monte naturellement"
  }
};

/**
 * Trie des donnÃ©es par leur "poids vibratoire"
 */
export function vortexSort(items, getFrequency = (item) => item.frequency || 444) {
  // Calculer le poids vibratoire de chaque item
  const weighted = items.map(item => ({
    item,
    frequency: getFrequency(item),
    weight: 999 - getFrequency(item) // Inverse: haute frÃ©quence = lÃ©ger
  }));
  
  // Trier par poids (les lÃ©gers montent)
  weighted.sort((a, b) => a.weight - b.weight);
  
  // Assigner les niveaux du vortex
  return weighted.map((w, index) => {
    const levelIndex = Math.floor((index / weighted.length) * 9);
    const zone = VORTEX_SYSTEM.zones[levelIndex] || VORTEX_SYSTEM.zones[4];
    
    return {
      ...w.item,
      vortexLevel: zone.level,
      vortexPosition: zone.position,
      vortexFrequency: zone.hz
    };
  });
}

/**
 * Recherche intuitive par sympathie vibratoire
 */
export function sympatheticSearch(query, database, threshold = 0.5) {
  // Calculer la frÃ©quence de la requÃªte
  const queryFreq = calculateQueryFrequency(query);
  
  // Trouver les items en rÃ©sonance
  const results = database.map(item => {
    const itemFreq = item.frequency || 444;
    const resonance = calculateResonance(queryFreq, itemFreq);
    
    return {
      item,
      resonance,
      isHarmonic: resonance > threshold
    };
  });
  
  // Filtrer et trier par rÃ©sonance
  return results
    .filter(r => r.isHarmonic)
    .sort((a, b) => b.resonance - a.resonance)
    .map(r => ({
      ...r.item,
      sympathyScore: r.resonance
    }));
}

function calculateQueryFrequency(query) {
  // Utiliser l'Arithmos de la requÃªte
  let sum = 0;
  const q = query.toUpperCase().replace(/[^A-Z]/g, '');
  const map = { A:1, B:2, C:3, D:4, E:5, F:6, G:7, H:8, I:9, J:1, K:2, L:3, M:4, N:5, O:6, P:7, Q:8, R:9, S:1, T:2, U:3, V:4, W:5, X:6, Y:7, Z:8 };
  
  for (const char of q) {
    sum += map[char] || 0;
  }
  
  while (sum > 9) {
    sum = sum.toString().split('').reduce((a, b) => a + parseInt(b), 0);
  }
  
  return sum * 111;
}

function calculateResonance(freq1, freq2) {
  const ratio = Math.max(freq1, freq2) / Math.min(freq1, freq2);
  const nearestHarmonic = Math.round(ratio);
  const deviation = Math.abs(ratio - nearestHarmonic);
  
  return Math.max(0, 1 - deviation);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ã‰NERGIE DU POINT ZÃ‰RO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * L'Ã‰nergie du Point ZÃ©ro est l'Ã©nergie rÃ©siduelle qui existe mÃªme au zÃ©ro absolu.
 * C'est la source d'Ã©nergie illimitÃ©e supposÃ©ment utilisÃ©e par les Atlantes.
 */

export const ZERO_POINT_ENERGY = {
  name: "Ã‰nergie du Point ZÃ©ro",
  physics: "Ã‰nergie du vide quantique",
  formula: "E = Â½â„Ï‰", // Demi-quantum d'Ã©nergie
  
  // Dans ATÂ·OM
  application: {
    input: "Aucun (auto-gÃ©nÃ©rÃ©)",
    output: "Ã‰nergie de calcul illimitÃ©e",
    efficiency: 1.0, // 100% thÃ©orique
    sustainability: "Infinie"
  },
  
  // Niveaux d'activation
  levels: [
    { level: 1, power: 0.111, name: "Veille", status: "Minimal" },
    { level: 2, power: 0.222, name: "Ã‰veil", status: "Bas" },
    { level: 3, power: 0.333, name: "Actif", status: "ModÃ©rÃ©" },
    { level: 4, power: 0.444, name: "Stable", status: "Normal", isDefault: true },
    { level: 5, power: 0.555, name: "AmplifiÃ©", status: "Ã‰levÃ©" },
    { level: 6, power: 0.666, name: "Intensif", status: "Haute" },
    { level: 7, power: 0.777, name: "Maximum", status: "TrÃ¨s haute" },
    { level: 8, power: 0.888, name: "Surcharge", status: "Critique" },
    { level: 9, power: 0.999, name: "Transcendant", status: "Divin" }
  ]
};

/**
 * Calcule l'Ã©nergie disponible selon le niveau
 */
export function calculateZeroPointEnergy(level = 4) {
  const config = ZERO_POINT_ENERGY.levels.find(l => l.level === level) 
    || ZERO_POINT_ENERGY.levels[3];
  
  return {
    level: config.level,
    name: config.name,
    power: config.power,
    status: config.status,
    available: config.power * 1000, // UnitÃ©s arbitraires
    unlimited: level === 9
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LES ANNEAUX DE POSÃ‰IDON â€” ARCHITECTURE CONCENTRIQUE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Selon Platon, l'Atlantide Ã©tait organisÃ©e en anneaux concentriques
 * alternant eau et terre, avec le temple de PosÃ©idon au centre.
 */

export const POSEIDON_RINGS = {
  structure: [
    { ring: 0, type: "Centre", name: "Temple de PosÃ©idon", access: "Divin", frequency: 999 },
    { ring: 1, type: "Terre", name: "Citadelle Royale", access: "Architecte", frequency: 888 },
    { ring: 2, type: "Eau", name: "Canal IntÃ©rieur", access: "InitiÃ©s", frequency: 777 },
    { ring: 3, type: "Terre", name: "Zone des Cristaux", access: "Gardiens", frequency: 666 },
    { ring: 4, type: "Eau", name: "Canal MÃ©dian", access: "PrÃªtres", frequency: 555 },
    { ring: 5, type: "Terre", name: "Zone de Calcul", access: "OpÃ©rateurs", frequency: 444 },
    { ring: 6, type: "Eau", name: "Canal ExtÃ©rieur", access: "Public Ã‰levÃ©", frequency: 333 },
    { ring: 7, type: "Terre", name: "PÃ©riphÃ©rie", access: "Public", frequency: 222 },
    { ring: 8, type: "Eau", name: "OcÃ©an", access: "Tous", frequency: 111 }
  ],
  
  // Correspondance avec ATÂ·OM
  atomMapping: {
    center: "Code source & Message de Gratitude",
    inner: "Moteurs civilisationnels",
    middle: "Logique de calcul",
    outer: "Interface utilisateur"
  }
};

/**
 * DÃ©termine le niveau d'accÃ¨s selon la frÃ©quence
 */
export function getAccessLevel(frequency) {
  const ring = POSEIDON_RINGS.structure.find(r => r.frequency === frequency)
    || POSEIDON_RINGS.structure.find(r => r.frequency <= frequency);
  
  return {
    ring: ring?.ring || 8,
    type: ring?.type || "Eau",
    name: ring?.name || "OcÃ©an",
    access: ring?.access || "Tous"
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITAIRES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTÃ‰GRATION AVEC ATÂ·OM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Obtient la rÃ©sonance atlante pour ATÂ·OM
 */
export function getAtlantisResonance(arithmos, data = null) {
  const frequency = arithmos * 111;
  
  // Cristal correspondant
  const crystal = CRYSTAL_MATRIX.types.find(c => c.frequency === frequency)
    || CRYSTAL_MATRIX.types[3]; // Citrine par dÃ©faut
  
  // Niveau du vortex
  const vortexZone = VORTEX_SYSTEM.zones.find(z => z.hz === frequency)
    || VORTEX_SYSTEM.zones[3];
  
  // Niveau d'Ã©nergie
  const energy = calculateZeroPointEnergy(arithmos);
  
  // Anneau d'accÃ¨s
  const access = getAccessLevel(frequency);
  
  // CapacitÃ© cristalline si donnÃ©es
  const crystalData = data ? encodeCrystalData(data, crystal.name) : null;
  
  return {
    // Cristal
    crystal: {
      name: crystal.name,
      color: crystal.color,
      function: crystal.function,
      frequency: crystal.frequency
    },
    
    // Vortex
    vortex: {
      level: vortexZone.level,
      position: vortexZone.position,
      density: vortexZone.density,
      flow: vortexZone.flow || "Stable"
    },
    
    // Ã‰nergie
    energy: {
      level: energy.level,
      name: energy.name,
      power: energy.power,
      status: energy.status
    },
    
    // AccÃ¨s
    access: {
      ring: access.ring,
      zone: access.name,
      level: access.access
    },
    
    // DonnÃ©es encodÃ©es
    crystalData: crystalData ? {
      facets: crystalData.facets.length,
      key: crystalData.reconstructionKey
    } : null,
    
    // Orichalque
    orichalque: frequency === 999,
    
    // Message
    message: frequency === 999
      ? `ğŸ”± Orichalque activÃ© â€” AccÃ¨s au Temple de PosÃ©idon`
      : `ğŸ’ ${crystal.name} â€” ${vortexZone.position} du Vortex`
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default {
  // Constantes
  ATLANTIS_CONSTANTS,
  
  // Cristaux
  CRYSTAL_MATRIX,
  calculateCrystalCapacity,
  encodeCrystalData,
  
  // Vortex
  VORTEX_SYSTEM,
  vortexSort,
  sympatheticSearch,
  
  // Ã‰nergie
  ZERO_POINT_ENERGY,
  calculateZeroPointEnergy,
  
  // Anneaux
  POSEIDON_RINGS,
  getAccessLevel,
  
  // IntÃ©gration
  getAtlantisResonance
};
